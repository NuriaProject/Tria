/* Copyright (c) 2014, The Nuria Project
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *    1. The origin of this software must not be misrepresented; you must not
 *       claim that you wrote the original software. If you use this software
 *       in a product, an acknowledgment in the product documentation would be
 *       appreciated but is not required.
 *    2. Altered source versions must be plainly marked as such, and must not be
 *       misrepresented as being the original software.
 *    3. This notice may not be removed or altered from any source
 *       distribution.
 */

#include "nuriagenerator.hpp"

#include <algorithm>

#include <QDateTime>
#include <QIODevice>
#include <QBuffer>
#include <QRegExp>
#include <QDebug>

#include <clang/Tooling/Tooling.h>
#include "definitions.hpp"
#include "defs.hpp"

NuriaGenerator::NuriaGenerator (Definitions *definitions)
	: m_definitions (definitions) , m_stringPos (0)
{
	
}

static QByteArray escapeName (QString name) {
	return name.replace (QRegExp ("[^A-Za-z0-9]"), "_").toLatin1 ();
}

static QByteArray identPrefix (QString name) {
	return QByteArrayLiteral ("tria_") + escapeName (name) + QByteArrayLiteral ("_");
}

QByteArray NuriaGenerator::toByteArray (const QString &string) {
	return QByteArrayLiteral ("QByteArrayLiteral (\"") + string.toUtf8 () + QByteArrayLiteral ("\")");
}

bool NuriaGenerator::generate (QIODevice *device) {
	QVector< ClassDef > classes = this->m_definitions->classDefintions ();
	StringSet declareTypes = this->m_definitions->declareTypes ();
	
	// 
//	qDebug() << "=> Declaring" << declareTypes;
//	qDebug() << "=> Already declared" << declaredTypes;
//	qDebug() << "=> Avoiding" << avoidedTypes;
	
	// Write prologue. Nothing really dynamic here
	writeHeader (device);
	
	// #include the processed file itself and go into our namespace
	device->write ("#include <nuria/metaobject.hpp>\n"
		       "#include <nuria/variant.hpp>\n"
		       "#include <QByteArray>\n"
		       "#include <QMetaType>\n"
		       "#include <QVector>\n"
		       "#include \"");
	device->write (this->m_definitions->sourceFileName ().toUtf8 ());
	device->write ("\"\n\n");
	
	// Q_DECLARE_METATYPE
	for (const ClassDef &def : classes) {
		writeDeclareMetatypeForClass (def, device);
	}
	
	for (const QString &typeName : declareTypes) {
		writeDeclareMetatype (typeName, device);
	}
	
	device->write ("\n"
		       "namespace TriaObjectData {\n\n");
	
	// Write common stuff
	device->write ("enum Categories {\n"
		       "  ObjectCategory = 0,\n"
		       "  MethodCategory = 1,\n"
		       "  FieldCategory = 2,\n"
		       "  EnumCategory = 3\n"
		       "};\n\n");
	
	// Generate class definitions. Write into a buffer.
	QBuffer classDefBuffer;
	classDefBuffer.open (QIODevice::ReadWrite);
	
	// 
	for (ClassDef &def : classes) {
		writeClassDef (def, &classDefBuffer);
	}
	
	// Write string buffer
//	writeStringBuffer (device);
	
	// Write buffer
	device->write (classDefBuffer.data ());
	
	// Generate helper class
	writeInstantiorClass (device);
	
	// Close namespace, done
	device->write ("}\n");
	
	return true;
}

int NuriaGenerator::registerString (const QString &string) {
	if (this->m_stringPositions.contains (string)) {
		return this->m_stringPositions.value (string);
	}
	
	// Push string on the buffer
	int offset = this->m_stringPos;
	this->m_stringPos += string.length () + 1;
	
	this->m_stringBuffer.append (string.toUtf8 ());
	this->m_stringBuffer.append ("\\0");
	
	// Cache and return.
	this->m_stringPositions.insert (string, offset);
	return offset;
}

QByteArray NuriaGenerator::stringAcessor (const QString &string) {
	int offset = registerString (string);
	
	QString access = QStringLiteral ("&stringBuffer[") +
			 QString::number (offset) +
			 QStringLiteral ("]");
	return access.toLatin1 ();
}

void NuriaGenerator::writeHeader (QIODevice *device) {
	device->write ("/*******************************************************************************\n"
		       " * Meta-code generated by Tria\n"
		       " * Source file: ");
	device->write (this->m_definitions->sourceFileName ().toUtf8 ());
	device->write ("\n"
		       " * Date: ");
	device->write (QDateTime::currentDateTime ().toString (Qt::ISODate).toLatin1 ());
	
	device->write ("\n"
		       " * LLVM version: " QT_STRINGIFY(LLVM_VERSION_MAJOR) "." QT_STRINGIFY(LLVM_VERSION_MINOR) "\n"
		       " *\n"
		       " * W A R N I N G!\n"
		       " * This code is auto-generated. All changes you make WILL BE LOST!\n"
		       "*******************************************************************************/\n\n");
	
}

void NuriaGenerator::writeStringBuffer (QIODevice *device) {
	static const int lineLength = 80;
	
	device->write ("static const char *stringBuffer = ");
	
	// 
	int length = this->m_stringBuffer.length ();
	for (int i = 0; i < length; i += lineLength) {
		device->write ("\n\"");
		device->write (this->m_stringBuffer.mid (i, lineLength));
		device->write ("\"");
	}
	
	//
	if (this->m_stringBuffer.isEmpty ()) {
		device->write ("\"\"");
	}
	
	device->write (";\n\n");
	
}

void NuriaGenerator::writeRegisterMetatypeForClass (const ClassDef &def, QIODevice *device) {
	writeRegisterMetatype (def.name + QStringLiteral ("*"), device);
	
	if (def.hasValueSemantics) {
		writeRegisterMetatype (def.name, device);
	}
	
}

void NuriaGenerator::writeRegisterMetatype (const QString &type, QIODevice *device) {
	device->write ("    qRegisterMetaType< ");
	device->write (type.toLatin1 ());
	device->write (" > ();\n");
	
}

void NuriaGenerator::writeDeclareMetatypeForClass (const ClassDef &def, QIODevice *device) {
	writeDeclareMetatype (def.name + QStringLiteral ("*"), device);
	
	if (def.hasValueSemantics) {
		writeDeclareMetatype (def.name, device);
	}
	
}

void NuriaGenerator::writeDeclareMetatype (const QString &type, QIODevice *device) {
	if (this->m_definitions->isTypeDeclared (type) || this->m_definitions->isTypeAvoided (type)) {
		return;
	}
	
	this->m_definitions->addDeclaredType (type);
	device->write ("Q_DECLARE_METATYPE(");
	device->write (type.toLatin1 ());
	device->write (");\n");
	
}

void NuriaGenerator::writeMemberConverters (const ClassDef &def, QIODevice *device) {
	for (const ConversionDef &cur : def.conversions) {
		if (this->m_definitions->isTypeAvoided (cur.fromType) ||
		    this->m_definitions->isTypeAvoided (cur.toType)) {
			continue;
		}
		
		if (cur.type == MemberMethod) {
			writeMemberConverter (cur, device);
		} else if (cur.type == StaticMethod) {
			writeStaticConverter (cur, device);
		}
		
	}
	
}

void NuriaGenerator::writeMemberConverter (const ConversionDef &def, QIODevice *device) {
	QByteArray from = escapeName (def.fromType);
	QByteArray to = escapeName (def.toType);
	
	device->write ("inline static ");
	device->write (def.toType.toLatin1 ());
	device->write (" *tria_convert_");
	device->write (from);
	device->write ("_to_");
	device->write (to);
	device->write (" (const ");
	device->write (def.fromType.toLatin1 ());
	device->write (" &value) {\n");
	if (!def.isConst) {
		device->write ("    ");
		device->write (def.fromType.toLatin1 ());
		device->write (" temp (value);\n");
	}
	
	device->write ("    return new ");
	device->write (def.toType.toLatin1 ());
	device->write (!def.isConst ? " (temp." : " (value.");
	device->write (def.methodName.toLatin1 ());
	device->write (" ());\n"
		       "}\n\n");
	
}

void NuriaGenerator::writeStaticConverter (const ConversionDef &def, QIODevice *device) {
	QByteArray from = escapeName (def.fromType);
	QByteArray to = escapeName (def.toType);
	
	device->write ("inline static ");
	device->write (def.toType.toLatin1 ());
	device->write (" *tria_convert_");
	device->write (from);
	device->write ("_to_");
	device->write (to);
	device->write (" (const ");
	device->write (def.fromType.toLatin1 ());
	device->write (" &value) {\n"
		       "    return new ");
	device->write (def.toType.toLatin1 ());
	device->write (" (");
	device->write (def.toType.toLatin1 ());
	device->write ("::");
	device->write (def.methodName.toLatin1 ());
	device->write (" (value));\n"
		       "}\n\n");
	
}

void NuriaGenerator::writeInstantiorClass (QIODevice *device) {
	QByteArray prefix = identPrefix (this->m_definitions->sourceFileName ());
	
	// Open class
	device->write ("struct Q_DECL_HIDDEN ");
	device->write (prefix);
	device->write ("Register {\n"
		       "  ");
	device->write (prefix);
	device->write ("Register () {\n");
	
	// Register additional types
	device->write ("    // Register additional needed types\n");
	for (const QString &typeName : this->m_definitions->declareTypes ()) {
		writeRegisterMetatype (typeName, device);
	}
	
	device->write ("\n");
	
	// Register all known classes
	for (const ClassDef &cur : this->m_definitions->classDefintions ()) {
		device->write ("    // Register class ");
		device->write (cur.name.toLatin1 ());
		device->write ("\n"
			       "    Nuria::MetaObject::registerMetaObject (new ");
		device->write (prefix);
		device->write (escapeName (cur.name));
		device->write ("_metaObject);\n");
		writeConversionRegisterers (cur, device);
		writeRegisterMetatypeForClass (cur, device);
		device->write ("\n");
	}
	// End class
	device->write ("  }\n"
		       "};\n\n");
	
	// Create global(!) instance
	device->write (prefix);
	device->write ("Register ");
	device->write (prefix);
	device->write ("instantior;\n\n");
	
}

void NuriaGenerator::writeConversionRegisterers (const ClassDef &def, QIODevice *device) {
	if (!def.hasValueSemantics) {
		return;
	}
	
	for (const ConversionDef &cur : def.conversions) {
		device->write ("    Nuria::Variant::registerConversion");
		
		if (cur.type == ConstructorMethod) { // Constructor
			device->write ("< ");
			device->write (cur.fromType.toLatin1 ());
			device->write (", ");
			device->write (cur.toType.toLatin1 ());
			device->write (" > ();\n");
		} else if (cur.type == MemberMethod || cur.type == StaticMethod) { // to*
			device->write (" (&tria_convert_");
			device->write (escapeName (cur.fromType));
			device->write ("_to_");
			device->write (escapeName (cur.toType));
			device->write (");\n");
		}
		
	}
	
}

template< typename T >
static bool sortByName (const T &lhs, const T &rhs) {
	return lhs.name < rhs.name;
}

static bool methodLess (const MethodDef &lhs, const MethodDef &rhs) {
	if (lhs.name == rhs.name) {
		return lhs.arguments.length () < rhs.arguments.length ();
	}
	
	return lhs.name < rhs.name;
}

static bool checkArgumentsForAvoidedTypes (const StringSet &avoid, const Variables &args) {
	for (const VariableDef &cur : args) {
		if (avoid.contains (cur.type)) {
			return true;
		}
		
	}
	
	return false;
}

static void filterMethods (const StringSet &avoid, Methods &methods) {
	for (int i = 0; i < methods.length (); i++) {
		const MethodDef &cur = methods.at (i);
		
		if ((!cur.name.isEmpty () && avoid.contains (cur.returnType)) ||
		    checkArgumentsForAvoidedTypes (avoid, cur.arguments)) {
			methods.remove (i);
			i--;
		}
		
	}
	
}

static void filterFields (const StringSet &avoid, Variables &fields) {
	for (int i = 0; i < fields.length (); i++) {
		const VariableDef &cur = fields.at (i);
		
		if (avoid.contains (cur.type)) {
			fields.remove (i);
			i--;
		}
		
	}
	
}

static int firstOptionalArgument (const MethodDef &method) {
	int i;
	for (i = 0; i < method.arguments.length (); i++) {
		if (method.arguments.at (i).isOptional) {
			break;
		}
		
	}
	
	return i;
}

static void expandMethodsWithOptionalArgs (Methods &methods) {
	
	for (auto it = methods.begin (); it != methods.end (); ++it) {
		MethodDef cur = *it; // Intentionally not a reference.
		int totalArgs = cur.arguments.length ();
		for (int i = firstOptionalArgument (cur); i < totalArgs; i++, ++it) {
			MethodDef overload = cur;
			overload.arguments.resize (i);
			it = methods.insert (it, overload);
		}
		
	}
	
}

void NuriaGenerator::writeClassDef (ClassDef &def, QIODevice *device) {
	QByteArray prefix = identPrefix (this->m_definitions->sourceFileName ());
	
	// Converters
	if (def.hasValueSemantics) {
		writeMemberConverters (def, device);
	}
	
	// Prologue
	device->write ("class Q_DECL_HIDDEN ");
	device->write (prefix);
	device->write (escapeName (def.name.toLatin1 ()));
	device->write ("_metaObject : public Nuria::MetaObject {\n"
		       "public:\n");
	
	// Generate _className and _metaTypeId
	device->write ("  QByteArray _className () const {\n"
		       "    return ");
	device->write (toByteArray (def.name));
	device->write (";\n"
		       "  }\n\n"
		       "  int _metaTypeId () const {\n"
		       "    return ");
	if (def.hasValueSemantics) {
		device->write ("qMetaTypeId< ");
		device->write (def.name.toLatin1 ());
		device->write (" > ();\n");
	} else {
		device->write ("0;\n");
	}
	
	device->write ("  }\n\n");
	
	device->write ("  int _pointerMetaTypeId () const {\n"
		       "    return qMetaTypeId< ");
	device->write (def.name.toLatin1 ());
	device->write (" * > ();\n"
		       "  }\n\n");
	
	// Generate various methods
	writeDestroyMethod (def, device);
	writeBasesMethod (def, device);
	writeCountMethods (def, device);
	writeAnnotationMethods (def, device);
	writeMethodMethods (def, device);
	writeFieldMethods (def, device);
	writeEnumMethods (def, device);
	writeGateCallMethod (def, device);
	
	// Done.
	device->write ("};\n\n");
	
	
}

void NuriaGenerator::writeDestroyMethod (const ClassDef &def, QIODevice *device) {
	device->write ("  void _destroy (void *instance) {\n"
		       "    delete reinterpret_cast< ");
	device->write (def.name.toLatin1 ());
	device->write (" * > (instance);\n"
		       "  }\n\n");
	
}

void NuriaGenerator::writeBasesMethod (const ClassDef &def, QIODevice *device) {
	device->write ("  QVector< QByteArray > _baseClasses () {\n"
		       "    return QVector< QByteArray > ");
	
	int count = def.bases.length ();
	if (count > 0) {
		device->write ("{ ");
		for (int i = 0; i < count; i++) {
			device->write (toByteArray (def.bases.at (i).name));
			if (i + 1 < count) {
				device->write (", ");
			}
			
		}
		
		device->write (" };\n");
	} else {
		device->write ("();\n");
	}
	
	device->write ("  }\n\n");
}

template< typename Container, typename T >
static void writeGenericSwitch (const Container &container, QIODevice *device, const QByteArray &variable,
				  std::function< QByteArray(const T &) > func) {
	if (!container.isEmpty ()) {
		device->write ("    switch (");
		device->write (variable);
		device->write (") {\n");
		
		int j = 0;
		for (const T &cur : container) {
			QByteArray insertion = func (cur);
			
			if (insertion.isEmpty ()) {
				continue;
			}
			
			device->write ("    case ");
			device->write (QByteArray::number (j));
			device->write (": ");
			device->write (insertion);
			device->write (";\n");
			j++;
			
		}
		
		device->write ("    }\n");
	}
	
}

template< typename Container, typename T >
static void writeGenericFunction (const Container &container, QIODevice *device, const QByteArray &signature,
				  const QByteArray &defaultResult, const QByteArray &variable,
				  std::function< QByteArray(const T &) > func,
				  const QString &prologue = QString()) {
	
	device->write ("  ");
	device->write (signature);
	device->write (" const {\n");
	
	if (!prologue.isEmpty ()) {
		device->write ("    ");
		device->write (prologue.toLatin1 ());
		device->write ("\n");
	}
	
	writeGenericSwitch (container, device, variable, func);
	
	device->write ("    return ");
	device->write (defaultResult);
	device->write (";\n"
		       "  }\n\n");
	
}

void NuriaGenerator::writeCountMethods (const ClassDef &def, QIODevice *device) {
	
	std::function< QByteArray(const MethodDef &) > annotationsMethod = [this](const MethodDef &def) {
		return QByteArrayLiteral ("return ") + QByteArray::number (def.annotations.length ());
	};
	
	std::function< QByteArray(const VariableDef &) > annotationsFields = [this](const VariableDef &def) {
		return QByteArrayLiteral ("return ") + QByteArray::number (def.annotations.length ());
	};
	
	std::function< QByteArray(const EnumDef &) > annotationsEnums = [this](const EnumDef &def) {
		return QByteArrayLiteral ("return ") + QByteArray::number (def.annotations.length ());
	};
	
	device->write ("  int _annotationCount (int category, int index) const {\n");
	device->write ("    switch (category) {\n");
	device->write ("    case ObjectCategory: return ");
	device->write (QByteArray::number (def.annotations.length ()));
	device->write (";\n");
	device->write ("    case MethodCategory:\n");
	writeGenericSwitch (def.methods, device, "index", annotationsMethod);
	device->write ("    break;\n"
		       "    case FieldCategory:\n");
	writeGenericSwitch (def.variables, device, "index", annotationsFields);
	device->write ("    break;\n"
		       "    case EnumCategory:\n");
	writeGenericSwitch (def.enums, device, "index", annotationsEnums);
	device->write ("    break;\n"
		       "    }\n"
		       "  return 0;\n"
		       "  }\n\n");
	
	// 
	device->write ("  int _methodCount () const {\n");
	device->write ("    return ");
	device->write (QByteArray::number (def.methods.length ()));
	device->write (";\n  }\n\n");
	
	// 
	device->write ("  int _fieldCount () const {\n");
	device->write ("    return ");
	device->write (QByteArray::number (def.variables.length ()));
	device->write (";\n  }\n\n");
	
	// 
	device->write ("  int _enumCount () const {\n");
	device->write ("    return ");
	device->write (QByteArray::number (def.enums.length ()));
	device->write (";\n  }\n\n");
	
}

static QByteArray writeAnnotationValue (const AnnotationDef &def) {
	if (def.type != CustomAnnotation) {
		return QByteArray ();
	}
	
	if (def.value.isEmpty ()) {
		return QByteArrayLiteral ("return QVariant ()");
	} else if (def.valueType == QMetaType::QString) {
		return QByteArrayLiteral ("return QStringLiteral (\"") + 
				def.value.toUtf8 () + QByteArrayLiteral ("\")");
	}
	
	return QByteArrayLiteral ("return QVariant::fromValue (") + def.value.toUtf8 () + QByteArrayLiteral (")");
	
}

template< typename Container, typename T >
static QByteArray annotationHelper (const Container &container, const QByteArray &variable,
				    std::function< QByteArray(const T &) > func) {
	QBuffer buffer;
	buffer.open (QIODevice::WriteOnly);
	writeGenericSwitch (container, &buffer, variable, func);
	
	if (buffer.buffer ().isEmpty ()) {
		return QByteArrayLiteral ("break");
	}
	
	return QByteArrayLiteral ("\n") + buffer.buffer () + QByteArrayLiteral ("    break");
}

template< typename T, typename Sub >
static std::function< QByteArray(const T &) > iterateAnnotationsFunc (Sub func) {
	return [func](const T &def) {
		return annotationHelper (def.annotations, "nth", func);
        };
}

void NuriaGenerator::writeAnnotationMethods (const ClassDef &def, QIODevice *device) {
	// Nuria::MetaObject::annotationName
	std::function< QByteArray(const AnnotationDef &) > annotationName =
			[this](const AnnotationDef &a) -> QByteArray {
		if (a.type != CustomAnnotation) {
			return QByteArray ();
		}
		
                return QByteArrayLiteral ("return ") + toByteArray (a.name);
        };
	
	device->write ("  QByteArray _annotationName (int category, int index, int nth) const {\n"
		       "    switch (category) {\n"
		       "    case ObjectCategory:\n");
	writeGenericSwitch (def.annotations, device, "nth", annotationName);
	device->write ("    break;\n"
		       "    case MethodCategory:\n");
	writeGenericSwitch (def.methods, device, "index", iterateAnnotationsFunc< MethodDef > (annotationName));
	device->write ("    break;\n"
		       "    case FieldCategory:\n");
	writeGenericSwitch (def.variables, device, "index", iterateAnnotationsFunc< VariableDef > (annotationName));
	device->write ("    break;\n"
		       "    case EnumCategory:\n");
	writeGenericSwitch (def.enums, device, "index", iterateAnnotationsFunc< EnumDef > (annotationName));
	device->write ("    break;\n"
		       "    }\n\n"
		       "    return QByteArray ();\n"
		       "  }\n\n");
	
	// Nuria::MetaObject::annotationValue
	std::function< QByteArray(const AnnotationDef &) > valueFunc = writeAnnotationValue;
	device->write ("  QVariant _annotationValue (int category, int index, int nth) const {\n"
		       "    switch (category) {\n"
		       "    case ObjectCategory:\n");
	writeGenericSwitch (def.annotations, device, "nth", valueFunc);
	device->write ("    break;\n"
		       "    case MethodCategory:\n");
	writeGenericSwitch (def.methods, device, "index", iterateAnnotationsFunc< MethodDef > (valueFunc));
	device->write ("    break;\n"
		       "    case FieldCategory:\n");
	writeGenericSwitch (def.variables, device, "index", iterateAnnotationsFunc< VariableDef > (valueFunc));
	device->write ("    break;\n"
		       "    case EnumCategory:\n");
	writeGenericSwitch (def.enums, device, "index", iterateAnnotationsFunc< EnumDef > (valueFunc));
	device->write ("    break;\n"
		       "    }\n\n"
		       "    return QVariant ();\n"
		       "  }\n\n");
	
}

static void methodDefToArgumentString (const MethodDef &m, QString &parameter, QString &arguments) {
	for (int i = 0; i < m.arguments.length (); i++) {
		const VariableDef &cur = m.arguments.at (i);
		parameter.append (cur.type);
		parameter.append (" ");
		parameter.append (cur.name);
		arguments.append (cur.name);
		
		if (i + 1 < m.arguments.length ()) {
			parameter.append (", ");
			arguments.append (", ");
		}
		
	}
	
}

static int findAnnotationByType (const Annotations &annotations, AnnotationType type) {
	for (int i = 0; i < annotations.length (); i++) {
		if (annotations.at (i).type == type) {
			return i;
		}
		
	}
	
	return -1;
}

static QString findRequirement (const Annotations &annotations) {
	int at = findAnnotationByType (annotations, RequireAnnotation);
	if (at < 0) {
		return QString ();
	}
	
	return annotations.at (at).value;
}

void NuriaGenerator::writeMethodMethods (const ClassDef &def, QIODevice *device) {
	
	// QByteArray methodName (int index) const
	std::function< QByteArray(const MethodDef &) > methodName = [this](const MethodDef &def) {
		return toByteArray (def.name);
	};
	
	writeMethodGeneric (def.methods, device, "QByteArray _methodName (int index)", 
			    "QByteArray ()", methodName);
	
	// MetaMethod::Type methodType (int index) const
	std::function< QByteArray(const MethodDef &) > methodType = [this](const MethodDef &def) {
		switch (def.type) {
		case ConstructorMethod: return QByteArrayLiteral ("Nuria::MetaMethod::Constructor");
		case DestructorMethod: return QByteArray ();
		case MemberMethod: return QByteArrayLiteral ("Nuria::MetaMethod::Method");
		case StaticMethod: return QByteArrayLiteral ("Nuria::MetaMethod::Static");
		}
	};
	
	writeMethodGeneric (def.methods, device, "Nuria::MetaMethod::Type _methodType (int index)", 
			    "Nuria::MetaMethod::Method", methodType);
	
	
	// QByteArray methodReturnType (int index) const
	std::function< QByteArray(const MethodDef &) > returnType = [this](const MethodDef &def) {
		return toByteArray (QString (def.returnType).remove (QLatin1Char (' ')));
	};
	
	writeMethodGeneric (def.methods, device, "QByteArray _methodReturnType (int index)", 
			    "QByteArray ()", returnType);
	
	// QVector< QByteArray > methodArgumentNames (int index) const
	std::function< QByteArray(const MethodDef &) > argumentNames = [this](const MethodDef &def) {
		QByteArray arr = QByteArrayLiteral ("QVector< QByteArray > ");
		
		int count = def.arguments.length ();
		if (count > 0) {
			arr.append ("{ ");
			
			for (int i = 0; i < count; i++) {
				arr.append (toByteArray (def.arguments.at (i).name));
				
				if (i + 1 < count) {
					arr.append (", ");
				}
				
			}
		
			arr.append (" }");
		} else {
			arr.append ("()");
		}
		
		return arr;
	};
	
	writeMethodGeneric (def.methods, device, "QVector< QByteArray > _methodArgumentNames (int index)", 
			    "QVector< QByteArray > ()", argumentNames);
	
	// QVector< QByteArray > methodArgumentTypes (int index) const
	std::function< QByteArray(const MethodDef &) > argumentTypes = [this](const MethodDef &def) {
		QByteArray arr = QByteArrayLiteral ("QVector< QByteArray > ");
		
		int count = def.arguments.length ();
		if (count > 0) {
			arr.append ("{ ");
			
			for (int i = 0; i < count; i++) {
				QString argType = def.arguments.at (i).type;
				arr.append (toByteArray (argType.remove (QLatin1Char (' '))));
				
				if (i + 1 < count) {
					arr.append (", ");
				}
				
			}
		
			arr.append (" }");
		} else {
			arr.append ("()");
		}
		
		return arr;
	};
	
	writeMethodGeneric (def.methods, device, "QVector< QByteArray > _methodArgumentTypes (int index)", 
			    "QVector< QByteArray > ()", argumentTypes);
	
	// Callback methodUnsafeCallback (void *instance, int index) const
	std::function< QByteArray(const MethodDef &) > unsafeCallback = [&def, this](const MethodDef &m) {
		return methodToCallback (def, m, false);
	};
	
	writeMethodGeneric (def.methods, device, "Nuria::Callback _methodUnsafeCallback (void *__instance, int index)", 
			    "Nuria::Callback ()", unsafeCallback);
	
	// Callback methodCallback (void *instance, int index) const
	std::function< QByteArray(const MethodDef &) > callback = [&def, this](const MethodDef &m) {
		return methodToCallback (def, m, true);
	};
	
	writeMethodGeneric (def.methods, device, "Nuria::Callback _methodCallback (void *__instance, int index)", 
			    "Nuria::Callback ()", callback);
	
	// bool methodArgumentTest (void *instance, int index) const
	std::function< QByteArray(const MethodDef &) > argumentTest = [&def, this](const MethodDef &m) {
		return generateMethodArgumentTester (def, m);
	};
	
	writeMethodGeneric (def.methods, device, "Nuria::Callback _methodArgumentTest (void *__instance, int index)", 
			    "Nuria::Callback ()", argumentTest);
	
}

void NuriaGenerator::writeFieldMethods (const ClassDef &def, QIODevice *device) {
	
	// QByteArray fieldName (int index) const
	std::function< QByteArray(const VariableDef &) > fieldName = [this](const VariableDef &var) {
		return toByteArray (var.name);
	};
	
	writeFieldGeneric (def.variables, device, "QByteArray _fieldName (int index)", "QByteArray ()", fieldName);
	
	// Nuria::MetaField::Access fieldAccess (int index) const
	std::function< QByteArray(const VariableDef &) > fieldAccess = [this](const VariableDef &var) {
		if (var.getter.isEmpty () == var.setter.isEmpty ()) {
			return QByteArrayLiteral ("Nuria::MetaField::ReadWrite");
		}
		
		return QByteArrayLiteral ("Nuria::MetaField::ReadOnly");
	};
	
	writeFieldGeneric (def.variables, device, "Nuria::MetaField::Access _fieldAccess (int index)",
			   "Nuria::MetaField::NoAccess", fieldAccess);
	
	// QByteArray fieldType (int index) const
	std::function< QByteArray(const VariableDef &) > fieldType = [this](const VariableDef &var) {
		return toByteArray (var.type);
	};
	
	writeFieldGeneric (def.variables, device, "QByteArray _fieldType (int index)", "QByteArray ()", fieldType);
	
	// QVariant fieldRead (int index, void *instance) const
	std::function< QByteArray(const VariableDef &) > fieldRead = [&def, this](const VariableDef &var) {
		return generateGetter (def, var);
	};
	
	writeFieldGeneric (def.variables, device, "QVariant _fieldRead (int index, void *instance)",
			   "QVariant ()", fieldRead);
	
	// bool fieldWrite (int index, void *instance, const QVariant &value) const
	std::function< QByteArray(const VariableDef &) > fieldWrite = [&def, this](const VariableDef &var) {
		return generateSetter (def, var);
	};
	
	writeGenericFunction (def.variables, device,
		      "bool _fieldWrite (int index, void *__instance, const QVariant &__value)",
		      "false", "index", fieldWrite);
	
}

void NuriaGenerator::writeEnumMethods (const ClassDef &def, QIODevice *device) {
	
	// QByteArray enumName (int index) const
	std::function< QByteArray(const EnumDef &) > enumName = [this](const EnumDef &e) {
		return QByteArrayLiteral ("return ") + toByteArray (e.name);
	};
	
	writeGenericFunction (def.enums, device, "QByteArray _enumName (int index)", "QByteArray ()", "index", enumName);
	
	// int enumElementCount (int index) const
	std::function< QByteArray(const EnumDef &) > enumCount = [this](const EnumDef &e) {
		return QByteArrayLiteral ("return ") + QByteArray::number (e.values.length ());
	};
	
	writeGenericFunction (def.enums, device, "int _enumElementCount (int index)", "-1", "index", enumCount);
	
	// QByteArray enumElementKey (int index, int at) const
	std::function< QByteArray(const EnumDef &) > enumKey = [def, this](const EnumDef &e) {
		QByteArray code;
		code.append ("\n"
			     "      switch (at) {\n");
		for (int i = 0; i < e.values.length (); i++) {
			code.append ("      case ");
			code.append (QByteArray::number (i));
			code.append (": return ");
			code.append (toByteArray (e.keys.at (i)));
			code.append (";\n");
		}
		
		code.append ("      } break;");
		return code;
	};
	
	writeGenericFunction (def.enums, device, "QByteArray _enumElementKey (int index, int at)",
			    "QByteArray ()", "index", enumKey);
	
	// int enumElementValue (int index, int at) const
	std::function< QByteArray(const EnumDef &) > enumValue = [def, this](const EnumDef &e) {
		QByteArray code;
		code.append ("\n"
			     "      switch (at) {\n");
		for (int i = 0; i < e.values.length (); i++) {
			QByteArray qualified = def.name.toLatin1 () + QByteArrayLiteral ("::") +
					       e.keys.at (i).toLatin1 ();
			code.append ("      case ");
			code.append (QByteArray::number (i));
			code.append (": return ");
			code.append (qualified);
			code.append (";\n");
		}
		
		code.append ("      } break;");
		return code;
	};
	
	writeGenericFunction (def.enums, device, "int _enumElementValue (int index, int at)",
			    "-1", "index", enumValue);
	
}

void NuriaGenerator::writeGateCallMethod (const ClassDef &def, QIODevice *device) {
	Q_UNUSED(def);
	
	device->write ("#define RESULT(Type) *reinterpret_cast< Type * > (result)\n"
		       "  void gateCall (GateMethod method, int category, int index, int nth, \n"
		       "                 void *result, void *additional) override {\n"
		       "    switch (method) {\n"
		       "    case Nuria::MetaObject::GateMethod::ClassName:\n"
		       "      RESULT(QByteArray) = _className (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MetaTypeId:\n"
		       "      RESULT(int) = _metaTypeId (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::PointerMetaTypeId:\n"
		       "      RESULT(int) = _pointerMetaTypeId (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::BaseClasses:\n"
		       "      RESULT(QVector< QByteArray >) = _baseClasses (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::AnnotationCount:\n"
		       "      RESULT(int) = _annotationCount (category, index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodCount:\n"
		       "      RESULT(int) = _methodCount (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::FieldCount:\n"
		       "      RESULT(int) = _fieldCount (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::EnumCount:\n"
		       "      RESULT(int) = _enumCount (); break;\n"
		       "    case Nuria::MetaObject::GateMethod::AnnotationName:\n"
		       "      RESULT(QByteArray) = _annotationName (category,  index, nth); break;\n"
		       "    case Nuria::MetaObject::GateMethod::AnnotationValue:\n"
		       "      RESULT(QVariant) = _annotationValue (category,  index, nth); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodName:\n"
		       "      RESULT(QByteArray) = _methodName (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodType:\n"
		       "      RESULT(Nuria::MetaMethod::Type) = _methodType (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodReturnType:\n"
		       "      RESULT(QByteArray) = _methodReturnType (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodArgumentNames:\n"
		       "      RESULT(QVector< QByteArray >) = _methodArgumentNames (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodArgumentTypes:\n"
		       "      RESULT(QVector< QByteArray >) = _methodArgumentTypes (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodCallback:\n"
		       "      RESULT(Nuria::Callback) = _methodCallback (additional, index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodUnsafeCallback:\n"
		       "      RESULT(Nuria::Callback) = _methodUnsafeCallback (additional, index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::MethodArgumentTest:\n"
		       "      RESULT(Nuria::Callback) = _methodArgumentTest (additional, index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::FieldName:\n"
		       "      RESULT(QByteArray) = _fieldName (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::FieldType:\n"
		       "      RESULT(QByteArray) = _fieldType (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::FieldRead:\n"
		       "      RESULT(QVariant) = _fieldRead (index, additional); break;\n"
		       "    case Nuria::MetaObject::GateMethod::FieldWrite: {\n"
		       "      void **argData = reinterpret_cast< void ** > (additional);\n"
		       "      const QVariant &value = *reinterpret_cast< QVariant * > (argData[1]);\n"
		       "      RESULT(bool) = _fieldWrite (index, argData[0], value);\n"
		       "    } break;\n"
		       "    case Nuria::MetaObject::GateMethod::FieldAccess:\n"
		       "      RESULT(Nuria::MetaField::Access) = _fieldAccess (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::EnumName:\n"
		       "      RESULT(QByteArray) = _enumName (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::EnumElementCount:\n"
		       "      RESULT(int) = _enumElementCount (index); break;\n"
		       "    case Nuria::MetaObject::GateMethod::EnumElementKey:\n"
		       "      RESULT(QByteArray) = _enumElementKey (index, nth); break;\n"
		       "    case Nuria::MetaObject::GateMethod::EnumElementValue:\n"
		       "      RESULT(int) = _enumElementValue (index, nth); break;\n"
		       "    case Nuria::MetaObject::GateMethod::DestroyInstance:\n"
		       "      _destroy (additional); break;\n"
		       "    }\n"
		       "  }\n");
	
}

void NuriaGenerator::writeMethodGeneric (const Methods &methods, QIODevice *device, const QByteArray &signature,
				    const QByteArray &defaultResult,
				    std::function< QByteArray(const MethodDef &) > func,
				    const QString &prologue) {
	std::function< QByteArray(const MethodDef &) > returner = [&func] (const MethodDef &m) {
		return QByteArrayLiteral ("return ") + func (m);
	};
	
	writeGenericFunction (methods, device, signature, defaultResult, "index", returner, prologue);
	
}

void NuriaGenerator::writeFieldGeneric (const Variables &variables, QIODevice *device, const QByteArray &signature,
				   const QByteArray &defaultResult,
				   std::function< QByteArray (const VariableDef &) > func) {
	std::function< QByteArray(const VariableDef &) > returner = [&func] (const VariableDef &v) {
		return QByteArrayLiteral ("return ") + func (v);
	};
	
	writeGenericFunction (variables, device, signature, defaultResult, "index", returner);
	
}


void NuriaGenerator::writeEnumGeneric (const Enums &enums, QIODevice *device, const QByteArray &signature,
				  const QByteArray &defaultResult,
				  std::function< QByteArray (const EnumDef &) > func) {
	std::function< QByteArray(const EnumDef &) > returner = [&func] (const EnumDef &v) {
	        return QByteArrayLiteral ("return ") + func (v);
        };
        
        writeGenericFunction (enums, device, signature, defaultResult, "index", returner);
	
}

static QString generateMethodChecker (const ClassDef &def, const MethodDef &m, const QString &requirement,
				      bool nonVoid, const QString &parameter, const QString &arguments,
				      const QString &onSuccess, const QString &onFailure) {
	QString checkerName = QStringLiteral ("_Check_") + m.name + QString::number (m.arguments.length ());
	QString requirementCall = requirement;
	QString prologue;
	
	if (m.type == MemberMethod) {
		prologue = QString ("struct %1 : public %2 { bool _nuria_check (%3) { return (%4); } };\n")
			   .arg (checkerName, def.name, parameter, requirement);
		
		requirementCall = QString ("reinterpret_cast< %1 * > (__instance)->_nuria_check (%2)")
				  .arg (checkerName, arguments);
	}
	
	// 
	if (nonVoid) {
		return QString ("%1return (%2) ? %3 : %4")
			.arg (prologue, requirementCall, onSuccess, onFailure);
	}
	
	return QString ("%1if (%2) %3").arg (prologue, requirementCall, onSuccess);
	
}

QByteArray NuriaGenerator::generateMethodArgumentTester (const ClassDef &def, const MethodDef &m) {
	QString requirement = findRequirement (m.annotations);
	
	// 
	if (requirement.isEmpty ()) {
		return QByteArrayLiteral ("Nuria::Callback ()");
	}
	
	// 
	QString parameter;
	QString arguments;
	
	methodDefToArgumentString (m, parameter, arguments);
	
	// 
	static const QString success = QStringLiteral("true");
	static const QString failure = QStringLiteral("false");
	QString check = generateMethodChecker (def, m, requirement, true, parameter,
					       arguments, success, failure);
	
	return QString ("Nuria::Callback::fromLambda ([__instance](%1){ %2; })")
			.arg (parameter, check).toLatin1 ();
	
}

QByteArray NuriaGenerator::methodToCallback (const ClassDef &def, const MethodDef &m, bool safe) {
	QString requirement = findRequirement (m.annotations);
	
	// 
	QString parameter;
	QString arguments;
	methodDefToArgumentString (m, parameter, arguments);
	
	// 
	bool nonVoid = (m.returnType != "void");
	QString inner;
	if (m.type == ConstructorMethod) {
		inner = QString ("new %1 (%2)").arg (def.name, arguments);
	} else if (m.type == MemberMethod) {
		inner = QString ("reinterpret_cast< %1 * > (__instance)->%2 (%3)")
			.arg (def.name, m.name, arguments);
	} else if (m.type == StaticMethod) {
		inner = QString ("%1::%2 (%3)").arg (def.name, m.name, arguments);
	}
	
	// 
	QString check;
	if (safe && !requirement.isEmpty ()) {
		static const QString qVariant = QStringLiteral("QVariant ()");
		QString fromValue;
		
		if (nonVoid) {
			fromValue = QStringLiteral("QVariant::fromValue (") + inner + QStringLiteral (")");
		} else {
			fromValue = inner;
		}
		
		check = generateMethodChecker (def, m, requirement, nonVoid, parameter, 
					       arguments, fromValue, qVariant);
		
	} else if (nonVoid) {
		check = QStringLiteral ("return ") + inner;
	} else {
		check = inner;
	}
	
	// 
	QString catcher (m.type == MemberMethod ? "__instance" : "");
	return QString ("Nuria::Callback::fromLambda ([%1](%2) { %3; })")
			.arg (catcher, parameter, check).toLatin1 ();
	
}

QByteArray NuriaGenerator::generateGetter (const ClassDef &def, const VariableDef &var) {
	QByteArray code = QByteArrayLiteral ("QVariant::fromValue (reinterpret_cast< ") +
			  def.name.toLatin1 () + QByteArrayLiteral (" * > (instance)->") ;
	if (!var.getter.isEmpty ()) {
		code.append (var.getter.toLatin1 ());
		code.append (" ()");
	} else {
		code.append (var.name.toLatin1 ());
	}
	
	code.append (")");
	return code;
}

QByteArray NuriaGenerator::generateSetter (const ClassDef &def, const VariableDef &var) {
	QString requirement = findRequirement (var.annotations);
	QString prologue;
	
	// 
	if (!requirement.isEmpty ()) {
		QString checkerName = QStringLiteral ("_Check_") + var.name;
		QString varName = (var.setter.isEmpty ()) ? var.name : var.setterArgName;
		
		prologue = QString ("struct %1 : public %2 { bool _nuria_check (%3 %4) { return (%5); } };")
			   .arg (checkerName, def.name, var.type, varName, requirement);
		
		requirement = QString ("reinterpret_cast< %1 * > (__instance)->_nuria_check (%2)")
			      .arg (checkerName, varName);
		
	}
	
	// 
	if (var.setter.isEmpty () && !var.getter.isEmpty ()) {
		return "return false";
	} else if (var.setter.isEmpty () && requirement.isEmpty ()) {
		QString s ("\n"
			   "      if (__value.userType () != qMetaTypeId< %1 > ()) {\n"
			   "        QVariant __v = Nuria::Variant::convert (__value, qMetaTypeId< %1 > ());\n"
			   "        if (!__v.isValid ()) { return false; }\n"
			   "        reinterpret_cast< %2 * > (__instance)->%3 = __v.value< %1 > ();\n"
			   "      } else {\n"
			   "        reinterpret_cast< %2 * > (__instance)->%3 = __value.value< %1 > ();\n"
			   "      } return true");
		return s.arg (var.type, def.name, var.name).toLatin1 ();
	} else if (var.setter.isEmpty () && !requirement.isEmpty ()) {
		QString s ("{\n"
			   "      QVariant __v = (__value.userType () != qMetaTypeId< %1 > ())\n"
			   "      ? Nuria::Variant::convert (__value, qMetaTypeId< %1 > ()) : __value;\n"
			   "      if (__v.userType () != qMetaTypeId< %1 > () && !__v.isValid ()) { return false; }\n"
			   "      %1 %4 = __v.value< %1 > ();\n"
			   "      %6\n"
			   "      if (!%5) { return false; }\n"
			   "      reinterpret_cast< %2 * > (__instance)->%3 = %4;\n"
			   "    } return true");
		return s.arg (var.type, def.name, var.name, var.name,
			      requirement, prologue).toLatin1 ();
	} else if (!var.setter.isEmpty () && requirement.isEmpty ()) {
		QString s ("\n"
		           "      if (__value.userType () != qMetaTypeId< %1 > ()) {\n"
		           "        QVariant __v = Nuria::Variant::convert (__value, qMetaTypeId< %1 > ());\n"
		           "        if (!__v.isValid ()) { return false; }\n"
		           "        reinterpret_cast< %2 * > (__instance)->%3 (__v.value< %1 > ());\n"
		           "      } else {\n"
		           "        %4reinterpret_cast< %2 * > (__instance)->%3 (__value.value< %1 > ());\n"
		           "      } return true");
		QString ret (var.setterReturnsBool ? "return" : "" );
	        return s.arg (var.type, def.name, var.setter, ret).toLatin1 ();
	} else if (!var.setter.isEmpty () && !requirement.isEmpty ()) {
		QString s ("{\n"
			   "      QVariant __v = (__value.userType () != qMetaTypeId< %1 > ())\n"
			   "      ? Nuria::Variant::convert (__value, qMetaTypeId< %1 > ()) : __value;\n"
			   "      if (__v.userType () != qMetaTypeId< %1 > () && !__v.isValid ()) { return false; }\n"
			   "      %1 %4 = __v.value< %1 > ();\n"
			   "      %7\n"
			   "      if (!%5) { return false; }\n"
			   "      %6reinterpret_cast< %2 * > (__instance)->%3 (%4);\n"
			   "    } return true");
		QString ret (var.setterReturnsBool ? "return" : "" );
		return s.arg (var.type, def.name, var.setter, var.setterArgName,
			      requirement, ret, prologue).toLatin1 ();
	}
	
	return QByteArray ();
}
